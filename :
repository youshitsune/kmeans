use std::f32::MAX_EXP;
use rand::prelude::*;
use raylib::prelude::*;
use raylib::ffi::GetScreenWidth;
use raylib::ffi::GetScreenHeight;
use raylib::ffi::SetConfigFlags;
use raylib::ffi::ConfigFlags::FLAG_WINDOW_RESIZABLE;
use raylib::ffi::KeyboardKey::*;

const K: i32 = 3;
const SAMPLE_R: f32 = 4.0;
const MEAN_R: f32 = SAMPLE_R*2.0;
const MIN_X: f32 = -20.0;
const MAX_X: f32 = 20.0;
const MIN_Y: f32 = -20.0;
const MAX_Y: f32 = 20.0;
const PI: f32 = 3.1415926535897;
const COLORS: [Color; 9] = [Color::YELLOW, Color::PINK, Color::BROWN, Color::GREEN, Color::LIME, Color::SKYBLUE, Color::PURPLE, Color::VIOLET, Color::BEIGE];


fn gen_float() -> f32{
    let mut rng = rand::thread_rng();
    return rng.gen();
}

fn vector_subtract(v1: Vector2, v2: Vector2) -> Vector2{
    return Vector2{x: v1.x - v2.x, y: v1.y - v2.y};
}

fn vector_length(v: Vector2) -> f32{
    return (v.x*v.x)+(v.y*v.y);
}

fn generate_cluster(center: Vector2, radius: f32, count: i32, samples: &mut Vec<Vector2>){
    for i in 0..count{
        let angle: f32 = gen_float()*2.0*PI;
        let mag: f32 = gen_float();
        let sample = Vector2 {x: center.x + angle.cos()*mag*radius, y: center.y + angle.sin()*mag*radius};
        samples.push(sample);
    }
}

fn project_sample(sample: Vector2) -> Vector2{
    let nx: f32 = (sample.x - MIN_X)/(MAX_X - MIN_X);
    let ny: f32 = (sample.y - MIN_Y)/(MAX_Y - MIN_Y);
    let w: f32 = unsafe{GetScreenWidth() as f32};
    let h: f32 = unsafe{GetScreenHeight() as f32};

    return Vector2{x: nx*w, y: h-ny*h};
}

fn main(){
    let mut clusters: Vec<Vec<Vector2>> = vec![];
    for _ in 0..K{
        clusters.push(Vec::<Vector2>::new());
    }
    let mut means: Vec<Vector2> = vec![];
    unsafe{SetConfigFlags(FLAG_WINDOW_RESIZABLE as u32)};
    let (mut rl, thread) = raylib::init()
        .size(800, 600)
        .title("K means")
        .build();
    let mut cluster: Vec<Vector2> = vec![];
    generate_cluster(Vector2{x:0.0,y:0.0}, 10.0, 100, &mut cluster);
    generate_cluster(Vector2{x: MIN_X*0.5, y: MAX_Y*0.5}, 5.0, 100, &mut cluster);
    generate_cluster(Vector2{x: MAX_X*0.5, y: MAX_Y*0.5}, 5.0, 100, &mut cluster);

    for _ in 0..K{
        means.push(Vector2{x: gen_float()*(MAX_X-MIN_X) + MIN_X, y: gen_float()*(MAX_Y-MIN_Y)+MIN_Y});
    }


    for i in 0..cluster.len(){
        let p: Vector2 = cluster[i];
        let mut k: usize = usize::MIN;
        let mut s: f32 = MAX_EXP as f32;
        for j in 0..K{
            let m: Vector2 = means[j as usize];
            let sm = vector_length(vector_subtract(p, m));
            if sm < s{
                s = sm;
                k = j as usize;
            }
        }
        clusters[k].push(p);
    }

    while !rl.window_should_close(){
        if rl.is_key_pressed(KEY_R){
            cluster = vec![];
            generate_cluster(Vector2{x:0.0,y:0.0}, 10.0, 100, &mut cluster);
            generate_cluster(Vector2{x: MIN_X*0.5, y: MAX_Y*0.5}, 5.0, 50, &mut cluster);
            generate_cluster(Vector2{x: MAX_X*0.5, y: MAX_Y*0.5}, 5.0, 50, &mut cluster);

            means = vec![];
            for i in 0..K{
                means.push(Vector2{x: gen_float()*(MAX_X-MIN_X) + MIN_X, y: gen_float()*(MAX_Y-MIN_Y)+MIN_Y});
            }
        }
        let mut d = rl.begin_drawing(&thread);
        d.clear_background(Color::get_color(0x181818AA));
        for i in 0..cluster.len(){
            d.draw_circle_v(project_sample(cluster[i]), SAMPLE_R, Color::RED);
        }
        for i in 0..K{
            d.draw_circle_v(project_sample(means[i as usize]), MEAN_R, COLORS[(i%COLORS.len() as i32) as usize]);
        }
    }
}
